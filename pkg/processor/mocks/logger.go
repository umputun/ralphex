// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/umputun/ralphex/pkg/status"
)

// LoggerMock is a mock implementation of processor.Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked processor.Logger
//		mockedLogger := &LoggerMock{
//			LogAnswerFunc: func(answer string)  {
//				panic("mock out the LogAnswer method")
//			},
//			LogDraftReviewFunc: func(action string, feedback string)  {
//				panic("mock out the LogDraftReview method")
//			},
//			LogQuestionFunc: func(question string, options []string)  {
//				panic("mock out the LogQuestion method")
//			},
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//			PrintFunc: func(format string, args ...any)  {
//				panic("mock out the Print method")
//			},
//			PrintAlignedFunc: func(text string)  {
//				panic("mock out the PrintAligned method")
//			},
//			PrintRawFunc: func(format string, args ...any)  {
//				panic("mock out the PrintRaw method")
//			},
//			PrintSectionFunc: func(section status.Section)  {
//				panic("mock out the PrintSection method")
//			},
//		}
//
//		// use mockedLogger in code that requires processor.Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// LogAnswerFunc mocks the LogAnswer method.
	LogAnswerFunc func(answer string)

	// LogDraftReviewFunc mocks the LogDraftReview method.
	LogDraftReviewFunc func(action string, feedback string)

	// LogQuestionFunc mocks the LogQuestion method.
	LogQuestionFunc func(question string, options []string)

	// PathFunc mocks the Path method.
	PathFunc func() string

	// PrintFunc mocks the Print method.
	PrintFunc func(format string, args ...any)

	// PrintAlignedFunc mocks the PrintAligned method.
	PrintAlignedFunc func(text string)

	// PrintRawFunc mocks the PrintRaw method.
	PrintRawFunc func(format string, args ...any)

	// PrintSectionFunc mocks the PrintSection method.
	PrintSectionFunc func(section status.Section)

	// calls tracks calls to the methods.
	calls struct {
		// LogAnswer holds details about calls to the LogAnswer method.
		LogAnswer []struct {
			// Answer is the answer argument value.
			Answer string
		}
		// LogDraftReview holds details about calls to the LogDraftReview method.
		LogDraftReview []struct {
			// Action is the action argument value.
			Action string
			// Feedback is the feedback argument value.
			Feedback string
		}
		// LogQuestion holds details about calls to the LogQuestion method.
		LogQuestion []struct {
			// Question is the question argument value.
			Question string
			// Options is the options argument value.
			Options []string
		}
		// Path holds details about calls to the Path method.
		Path []struct {
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// PrintAligned holds details about calls to the PrintAligned method.
		PrintAligned []struct {
			// Text is the text argument value.
			Text string
		}
		// PrintRaw holds details about calls to the PrintRaw method.
		PrintRaw []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// PrintSection holds details about calls to the PrintSection method.
		PrintSection []struct {
			// Section is the section argument value.
			Section status.Section
		}
	}
	lockLogAnswer      sync.RWMutex
	lockLogDraftReview sync.RWMutex
	lockLogQuestion    sync.RWMutex
	lockPath           sync.RWMutex
	lockPrint          sync.RWMutex
	lockPrintAligned   sync.RWMutex
	lockPrintRaw       sync.RWMutex
	lockPrintSection   sync.RWMutex
}

// LogAnswer calls LogAnswerFunc.
func (mock *LoggerMock) LogAnswer(answer string) {
	if mock.LogAnswerFunc == nil {
		panic("LoggerMock.LogAnswerFunc: method is nil but Logger.LogAnswer was just called")
	}
	callInfo := struct {
		Answer string
	}{
		Answer: answer,
	}
	mock.lockLogAnswer.Lock()
	mock.calls.LogAnswer = append(mock.calls.LogAnswer, callInfo)
	mock.lockLogAnswer.Unlock()
	mock.LogAnswerFunc(answer)
}

// LogAnswerCalls gets all the calls that were made to LogAnswer.
// Check the length with:
//
//	len(mockedLogger.LogAnswerCalls())
func (mock *LoggerMock) LogAnswerCalls() []struct {
	Answer string
} {
	var calls []struct {
		Answer string
	}
	mock.lockLogAnswer.RLock()
	calls = mock.calls.LogAnswer
	mock.lockLogAnswer.RUnlock()
	return calls
}

// LogDraftReview calls LogDraftReviewFunc.
func (mock *LoggerMock) LogDraftReview(action string, feedback string) {
	if mock.LogDraftReviewFunc == nil {
		panic("LoggerMock.LogDraftReviewFunc: method is nil but Logger.LogDraftReview was just called")
	}
	callInfo := struct {
		Action   string
		Feedback string
	}{
		Action:   action,
		Feedback: feedback,
	}
	mock.lockLogDraftReview.Lock()
	mock.calls.LogDraftReview = append(mock.calls.LogDraftReview, callInfo)
	mock.lockLogDraftReview.Unlock()
	mock.LogDraftReviewFunc(action, feedback)
}

// LogDraftReviewCalls gets all the calls that were made to LogDraftReview.
// Check the length with:
//
//	len(mockedLogger.LogDraftReviewCalls())
func (mock *LoggerMock) LogDraftReviewCalls() []struct {
	Action   string
	Feedback string
} {
	var calls []struct {
		Action   string
		Feedback string
	}
	mock.lockLogDraftReview.RLock()
	calls = mock.calls.LogDraftReview
	mock.lockLogDraftReview.RUnlock()
	return calls
}

// LogQuestion calls LogQuestionFunc.
func (mock *LoggerMock) LogQuestion(question string, options []string) {
	if mock.LogQuestionFunc == nil {
		panic("LoggerMock.LogQuestionFunc: method is nil but Logger.LogQuestion was just called")
	}
	callInfo := struct {
		Question string
		Options  []string
	}{
		Question: question,
		Options:  options,
	}
	mock.lockLogQuestion.Lock()
	mock.calls.LogQuestion = append(mock.calls.LogQuestion, callInfo)
	mock.lockLogQuestion.Unlock()
	mock.LogQuestionFunc(question, options)
}

// LogQuestionCalls gets all the calls that were made to LogQuestion.
// Check the length with:
//
//	len(mockedLogger.LogQuestionCalls())
func (mock *LoggerMock) LogQuestionCalls() []struct {
	Question string
	Options  []string
} {
	var calls []struct {
		Question string
		Options  []string
	}
	mock.lockLogQuestion.RLock()
	calls = mock.calls.LogQuestion
	mock.lockLogQuestion.RUnlock()
	return calls
}

// Path calls PathFunc.
func (mock *LoggerMock) Path() string {
	if mock.PathFunc == nil {
		panic("LoggerMock.PathFunc: method is nil but Logger.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedLogger.PathCalls())
func (mock *LoggerMock) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LoggerMock) Print(format string, args ...any) {
	if mock.PrintFunc == nil {
		panic("LoggerMock.PrintFunc: method is nil but Logger.Print was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(format, args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//
//	len(mockedLogger.PrintCalls())
func (mock *LoggerMock) PrintCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// PrintAligned calls PrintAlignedFunc.
func (mock *LoggerMock) PrintAligned(text string) {
	if mock.PrintAlignedFunc == nil {
		panic("LoggerMock.PrintAlignedFunc: method is nil but Logger.PrintAligned was just called")
	}
	callInfo := struct {
		Text string
	}{
		Text: text,
	}
	mock.lockPrintAligned.Lock()
	mock.calls.PrintAligned = append(mock.calls.PrintAligned, callInfo)
	mock.lockPrintAligned.Unlock()
	mock.PrintAlignedFunc(text)
}

// PrintAlignedCalls gets all the calls that were made to PrintAligned.
// Check the length with:
//
//	len(mockedLogger.PrintAlignedCalls())
func (mock *LoggerMock) PrintAlignedCalls() []struct {
	Text string
} {
	var calls []struct {
		Text string
	}
	mock.lockPrintAligned.RLock()
	calls = mock.calls.PrintAligned
	mock.lockPrintAligned.RUnlock()
	return calls
}

// PrintRaw calls PrintRawFunc.
func (mock *LoggerMock) PrintRaw(format string, args ...any) {
	if mock.PrintRawFunc == nil {
		panic("LoggerMock.PrintRawFunc: method is nil but Logger.PrintRaw was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintRaw.Lock()
	mock.calls.PrintRaw = append(mock.calls.PrintRaw, callInfo)
	mock.lockPrintRaw.Unlock()
	mock.PrintRawFunc(format, args...)
}

// PrintRawCalls gets all the calls that were made to PrintRaw.
// Check the length with:
//
//	len(mockedLogger.PrintRawCalls())
func (mock *LoggerMock) PrintRawCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockPrintRaw.RLock()
	calls = mock.calls.PrintRaw
	mock.lockPrintRaw.RUnlock()
	return calls
}

// PrintSection calls PrintSectionFunc.
func (mock *LoggerMock) PrintSection(section status.Section) {
	if mock.PrintSectionFunc == nil {
		panic("LoggerMock.PrintSectionFunc: method is nil but Logger.PrintSection was just called")
	}
	callInfo := struct {
		Section status.Section
	}{
		Section: section,
	}
	mock.lockPrintSection.Lock()
	mock.calls.PrintSection = append(mock.calls.PrintSection, callInfo)
	mock.lockPrintSection.Unlock()
	mock.PrintSectionFunc(section)
}

// PrintSectionCalls gets all the calls that were made to PrintSection.
// Check the length with:
//
//	len(mockedLogger.PrintSectionCalls())
func (mock *LoggerMock) PrintSectionCalls() []struct {
	Section status.Section
} {
	var calls []struct {
		Section status.Section
	}
	mock.lockPrintSection.RLock()
	calls = mock.calls.PrintSection
	mock.lockPrintSection.RUnlock()
	return calls
}
